# MCP Framework - Working Memory

## üî¥ **CURRENT STATUS: CRITICAL SSE NOTIFICATION FIX IN PROGRESS (DAY 3+)**

**MCP Inspector Compatibility**: ‚úÖ **FIXED** - Tool execution timeout issue resolved (2025-08-27)  
**MCP Streamable HTTP**: ‚ö†Ô∏è **DISABLED FOR TOOL CALLS** - Temporarily disabled due to client compatibility issues  
**Session Management**: ‚úÖ **WORKING** - Server creates UUID v7 sessions, client receives via headers  
**SSE Notification Delivery**: üî¥ **CRITICAL ISSUE** - Notifications generated but not delivered to clients
**Test Validation**: ‚ö†Ô∏è **PARTIAL** - `client-initialise-report` shows MCP compliant but SSE notifications fail

### SSE Notification Delivery Crisis (Day 3+ - PRIORITY FIX)
- **Issue**: SSE notifications generated by tools but never delivered to clients
- **Root Cause**: StreamManager uses `broadcast::channel` which violates MCP specification
- **MCP Spec Violation**: "server MUST NOT broadcast the same message across multiple streams"
- **Symptom**: Server logs "No active SSE subscribers" when notifications sent
- **Evidence**: Tool execution works, notifications stored (event_id=1,2), but client never receives

### Previous Fix Summary  
- **Issue**: MCP Inspector v0.16.5 was timing out on tool calls with "Request timed out" error
- **Root Cause**: SSE streaming responses for tool calls were incompatible with MCP Inspector expectations  
- **Solution**: Temporarily disabled MCP Streamable HTTP for `tools/call` - all operations now return JSON responses
- **Impact**: Full MCP Inspector compatibility restored while maintaining SSE infrastructure for future use

### Working Test Commands
```bash
# Test MCP compliance and compatibility
cargo run --example client-initialise-server -- --port 52935
cargo run --example client-initialise-report -- --url http://127.0.0.1:52935/mcp

# Test MCP Inspector compatibility  
cargo run -p minimal-server  # Start server on port 8641
# Connect with MCP Inspector v0.16.5 ‚Üí Works perfectly (no timeouts)

# Expected output: "‚úÖ üéÜ FULLY MCP COMPLIANT: Session management working!"
```

## üèóÔ∏è **ARCHITECTURE OVERVIEW**

### MCP Streamable HTTP Implementation Status
- **POST + `Accept: text/event-stream`** ‚Üí ‚ö†Ô∏è **DISABLED** for tool calls (compatibility mode)
- **POST + `Accept: application/json`** ‚Üí ‚úÖ **WORKING** - Standard JSON responses for all operations  
- **GET /mcp SSE** ‚Üí ‚úÖ **WORKING** - Persistent server-initiated event streams  
- **Session Isolation** ‚Üí Each session has independent notification channels
- **SSE Resumability** ‚Üí Last-Event-ID support with monotonic event IDs

**Note**: SSE tool streaming temporarily disabled at `session_handler.rs:383-386` pending client compatibility improvements

### Core Components
- **SessionMcpHandler** - Bridges POST JSON-RPC and GET SSE handling
- **StreamManager** - Manages SSE connections and event replay
- **NotificationBroadcaster** - Routes notifications to correct sessions  
- **SessionStorage Trait** - Pluggable backend abstraction (InMemory, SQLite, etc.)

## üìã **MCP NOTIFICATION TYPES**

### Standard MCP Notifications (JSON-RPC Format)
1. **`notifications/message`** - Logging and debug messages
2. **`notifications/progress`** - Progress tracking with progressToken  
3. **`notifications/cancelled`** - Request cancellation
4. **`notifications/resources/list_changed`** - Resource list updates
5. **`notifications/resources/updated`** - Individual resource changes  
6. **`notifications/tools/list_changed`** - Tool list updates

### Notification Format (Required)
```json
{
  "jsonrpc": "2.0",
  "method": "notifications/progress", 
  "params": {
    "progressToken": "token123",
    "progress": 50,
    "total": 100,
    "message": "Processing..."
  }
}
```

## üö® **CRITICAL REQUIREMENTS**

### Session Management
- **üö® SERVER-PROVIDED SESSIONS**: Session IDs MUST be generated by server, never by client
- **UUID v7**: Always use `Uuid::now_v7()` for session IDs (temporal ordering)
- **Header Flow**: Server creates session ‚Üí `Mcp-Session-Id` header ‚Üí Client uses ID

### Framework Design  
- **üö® ZERO-CONFIG**: Users NEVER specify method strings - framework auto-determines ALL methods from types
- **Extend Existing**: Improve existing components, NEVER create "enhanced" versions  
- **JSON-RPC Compliance**: All notifications MUST use proper JSON-RPC format with `jsonrpc: "2.0"`

### Development Standards
- **Zero Warnings**: `cargo check` must show 0 warnings
- **MCP Compliance**: Use ONLY official methods from 2025-06-18 spec
- **SSE Standards**: WHATWG compliant - one connection = one stream per session

## üîß **ZERO-CONFIG PATTERN**

```rust
// Framework auto-determines ALL methods from types
let server = McpServer::builder()
    .tool_fn(calculator)                        // Framework ‚Üí tools/call  
    .notification_type::<ProgressNotification>() // Framework ‚Üí notifications/progress
    .notification_type::<MessageNotification>()  // Framework ‚Üí notifications/message
    .build()?;

// Users NEVER specify method strings anywhere!
```

## üîß **SSE STREAMING ARCHITECTURAL ANALYSIS**

### **Root Cause of MCP Inspector Compatibility Issues**

**Problem**: The current `create_post_sse_stream` implementation uses `Full<Bytes>` for static SSE responses:

```rust
// Current implementation (problematic)
pub async fn create_post_sse_stream() -> Result<Response<Full<Bytes>>, StreamError> {
    let mut sse_content = String::new();
    // Hard-coded 50ms sleep hoping to catch async notifications
    tokio::time::sleep(Duration::from_millis(50)).await;
    // Build static string response
    sse_content.push_str(&response_sse);
    // Return static response that closes immediately
    Ok(Response::builder().body(Full::new(Bytes::from(sse_content))))
}
```

**Issues**:
1. **Static Response**: `Full<Bytes>` creates finite responses that close immediately
2. **Timing Issues**: Artificial 50ms sleep doesn't guarantee notification capture  
3. **No Real Streaming**: Not compatible with clients expecting persistent connections
4. **Connection Lifecycle**: Closes before real-time notifications can be sent

### **Future MCP Streamable HTTP Improvements**

**Proper Implementation Required**:
1. **True Streaming**: Use `StreamBody` instead of `Full<Bytes>`
2. **Real-time Notifications**: Immediate tool response + ongoing notification stream  
3. **Connection Management**: Proper keep-alive and graceful closure
4. **Client Detection**: Auto-detect client capabilities for SSE vs JSON responses

**Architecture Decision**: Temporarily disable SSE tool streaming until proper streaming implementation available.

## üèõÔ∏è **CRITICAL ARCHITECTURE DECISION: HYBRID NOTIFICATION SYSTEM** 

### **Problem Statement (2025-08-27)**
Initial attempts to fix SSE notification delivery oscillated between two broken approaches:
1. **Shared StreamManager** across all sessions ‚Üí Violated session isolation
2. **Per-session StreamManager** with no global coordination ‚Üí Broke server-wide broadcasts

### **Solution: Single StreamManager with Internal Session Management**

**Decision**: Implement **single shared StreamManager** that internally manages per-session channels:
- **Session Isolation**: Internal HashMap<SessionId, HashMap<ConnectionId, Sender>> provides session separation
- **Server-wide Broadcasting**: Single StreamManager iterates all sessions for broadcasts  
- **Connection Reuse**: Single StreamManager persists across all HTTP connections

```rust
// CORRECTED ARCHITECTURE: Single StreamManager with internal session management
pub struct StreamManager<S: SessionStorage> {
    storage: Arc<S>,
    // ‚úÖ Internal per-session isolation via session_id keying
    connections: Arc<RwLock<HashMap<String, HashMap<ConnectionId, mpsc::Sender<SseEvent>>>>>,
    config: StreamConfig,
}

impl StreamManager {
    // Session-specific notifications
    pub async fn broadcast_to_session(&self, session_id: &str, ...) -> Result<u64, StreamError>
    
    // Server-wide broadcasts (iterates all sessions internally)
    pub async fn broadcast_to_all_sessions(&self, ...) -> Result<Vec<String>, StreamError>
}
```

### **Architecture Benefits**
1. **Session Isolation**: Internal HashMap keying by session_id provides complete session separation
2. **Global Coordination**: Single StreamManager can iterate all sessions for server-wide broadcasts  
3. **Resource Efficiency**: One StreamManager instance shared across all HTTP connections
4. **MCP Compliance**: Maintains "one connection per session" requirement while enabling broadcasts
5. **Simplified Architecture**: No complex registry patterns - just internal session management

### **Use Cases**
- **Session-specific**: `broadcast_to_session()` sends notifications only to specific session
- **Server-wide**: `broadcast_to_all_sessions()` sends system logs to ALL connected clients  
- **Connection Persistence**: Single StreamManager persists across HTTP connection lifecycle

### **Implementation Status**  
- ‚úÖ StreamManager with internal per-session management (existing)
- ‚è≥ Add `broadcast_to_all_sessions()` method to StreamManager
- üîÑ Update `SessionMcpHandler` to use single shared StreamManager 
- üîÑ Update `HttpMcpServer` to create shared StreamManager instance
- ‚è≥ Remove complex GlobalStreamManagerRegistry approach

**Rationale**: Single StreamManager with internal session management is the elegant solution that provides both session isolation (via internal HashMap keying) and server-wide broadcasting (via iteration over all sessions) without architectural complexity.

## üìö **ARCHITECTURE REFERENCES**

- **Complete Documentation**: See `MCP_SESSION_ARCHITECTURE.md` for detailed system architecture
- **Examples**: See `EXAMPLES_SUMMARY.md` for 26+ working examples showcasing all features  
- **Progress Tracking**: See `TODO_TRACKER.md` for current development status and next actions
- **Test Validation**: `client-initialise-report` provides comprehensive MCP compliance testing